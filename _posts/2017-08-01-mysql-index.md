---
layout:     post
title:      "MySQL 构建高性能索引"
subtitle:   "学习 MySQL 索引的构建"
date:       2017-08-01
author:     "JianFeng"
header-img: "img/blog/2017-07-30-mysql.png"
catalog: true
tags:
    - MySQL
---

> 学习 MySQL 索引的构建

# MySQL 联合索引引发的悲剧和思考

今天接到DBA一个慢SQL的报警，让紧急处理这个问题以免影响其他数据库访问。其实昨天项目上线之后，一直间歇性报警，已经发现是慢SQL的原因了，定时异步任务执行的效率非常低，问题可能就出在数据库上。每天几百万的记录写入，数据量上升很快，任何一点微小的问题都有可能拖垮整个应用。

这是一个计费表，字段有十几个，大概相关的几个字段是




正确的建立索引能提高我们DB的性能，但是错误的使用索引，不仅不能给我们带来性能上的提升，反而会给IO带来不必要的压力。

## 单列索引

索引建了也不一定能通过索引查到数据，下面这条SQL，id是主键索引

	select user_id from user where id + 1 = 2;

查找 id + 1 = 2 的用户的用户 Id ，查询条件包含了索引，但效率和没加索引是一样的。

它是这么比较的：用每个id + 1，然后和 2 作比较，最坏的情况是全表扫描。

正确的SQL应该这样：

	select user_id from user where id = 1;
	
运算都放在条件的右边，这样才能使用该索引。


## 前缀索引
在某些极端的情况下，我们可能要通过字符串来查询表中的信息，这个字符串可能很长，我们不可能用那么长的字符串作为索引，因为建索引是要产生额外的硬盘消耗的，在进行查询时还要从硬盘写入内存查询，造成大量的IO，这是得不偿失的。好在 MySQL 支持前缀索引，可以选择一定数量的字符作为前缀索引，可以大大节省索引消耗的空间。前缀索引也是有不足，会降低索引的选择性。

### 什么是选择性？

索引的选择性是指不重复的索引值和该数据表的总条数之比。数据表总条数为x，那么索引的选择性的值为1/x到1。索引的选择性越高查询效率越高，选择性越高的索引能在查询时过滤掉更多的行。InnoDB 引擎默认使用 B-tree 作为索引的实现，B-tree 是基于二分查找和多叉树实现的，所以选择性越高查找效率越高。

前缀索引是一种能使索引更小、更快的有效方法，但是它还有其他的缺点，MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也不能使用前缀索引做覆盖扫描。

### 覆盖扫描

## 多列索引

多列索引顾名思义就是建多个列的索引，也可以成为联合索引，刚接触索引的同学可能理解成建多个单列索引，其实不然。

	select user_id from user where id = 1 and user_id = 2

联合索引并不是伴随着 MySQL 出身的，在 MySQL 5.0 版本之前，是不支持多列索引的，这个查询语句放在老版本会导致数据库全表扫描，除非使用 UNION


	select user_id from user where id = 1 
	UNION ALL 
	select user_id from user where user_id = 1


