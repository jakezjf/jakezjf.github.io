---
layout:     post
title:      "MySQL 索引的实现原理"
subtitle:   "学习 MySQL InnoDB 和 MyISAM 存储引擎索引的实现"
date:       2017-02-19
author:     "JianFeng"
header-img: ""
catalog: true
tags:
    - MySQL
---

> 学习 MySQL InnoDB 和 MyISAM 存储引擎索引的实现



# 索引

索引是我们在使用 MySQL 中经常遇到的，索引建立的好坏直接影响了我们的查询性能，建立索引是十分有讲究的。对于不同的 MySQL 存储引擎支持的索引类型也有所不同。



# InnoDB 下的索引

InnoDB 的索引实现主要有以下三种：

- B+树索引
- 全文索引
- 哈希索引


# 二分查找算法

学习B+树之前，我们先了解一下二分查找，有助于我们了解B+树的实现。

二分查找法也称为折半查找法，用来查找一组有序的记录数组中的某一个记录，其思想是将数据先进行有序处理，在查找过程中采用跳跃查找的方式，比如：1，2，3，4，5，6，7，8，9，10，需要找到8这个元素，数组初始下标为0，长度为10，折半查找，找到数组中间的元素 6 ，元素 6 左边的元素都小于 6 ，右边的元素都大于 6 。然后用 6 和 要查找的元素对比，发现 8 大于 6 ，说明我们要找的元素在 6 的右部分。在 7，8，9，10 这剩下几个元素中查找，折半后，中间的元素为 8 ，8 和 8 相等，找到该元素，使用传统方法顺序遍历，我们可能查找的复杂度为 O(n)，使用折半查找法时间复杂度为 O(logN)，是不是快了很多！

##### 二分查找法的实现

    public static void half(int[] arr,int target){
        int low = 0;
        int hight = arr.length-1;
        while(low<=hight){
            int mid = (low + hight) / 2;
            System.out.println(arr[mid]);
            if(arr[mid] == target){
                System.out.println(arr[mid]);
                return;
            }
            if(arr[mid] > target){
                hight = mid - 1;
            }else{
                low = mid + 1;
            }
        }
    }
    
    public static int[] arr = {1,2,3,4,5,6,7,8,9,10};
    
    public static void main(String[] args){
    	half(arr,8);
    }
    
运行程序将打印出 8 。




# B+树索引

B+树索引是从二叉树演化而来的，所以 B+树 的结构类似二叉树，二叉查找树是一个经典的数据结构，在二叉查找树中左子树的值都比根节点小，右子树都比根节点大。，比如在下面这课查找树中我们要找到元素8


![](/img/blog/2017-02-19-mysql.png)

根节点的值为5，元素 8 大于 5，说明 8 在该二叉查找树的右子树，在右子树进行查找，找到 7 ，发现 8 大于 7 ，然后查找 7 的右孩子，7 的右孩子为 8 ，找到了。二叉查找树平均查找速度要比顺序查找要快。但是，也会遇到一些极端的情况,看看下面这棵二叉查找树：

![](/img/blog/2017-02-19-mysql0.png)

当我要寻找元素 1 时，我们的查找顺序是这样的：6 -> 5 -> 4 -> 2 -> 1。加入使用顺序查找，查找次数为1，但是使用二叉查找树的次数为5。若想是二叉树的查找效率达到最大的话，那么我们需要保证这棵二叉树平衡的，平衡二叉树又称为AVL树。平衡二叉树必须满足以下条件：

- 符合二叉查找树定义
- 必须满足任何节点的两个子树的高度最大差为1。

像刚刚的二叉树就不是平衡二叉树

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有的记录节点都是按键值的大小进行排序，存放在最底层的叶子节点上，由个叶子节点指针进行连接。看看下图，高度为2的一棵B+树。


![](/img/blog/2017-02-19-mysql1.png)

可以看到所有的记录都在叶子节点上，都是有序的，假如用户从头开始遍历，想要查找想要的数据，那么最坏时间复杂度为 O(n) ，这样的效率算是很低下的。

使用B+树我们能快速的找到自己需要的信息，比如找到元素 13 ，使用顺序查找需要 8 次，使用B+树只需要 4 次。

# B+树插入操作

数据库的数据是经常更新的，而且更新频率很快，显然我们建的索引也要随着数据的更新而调整自身的索引结构。为了保证B+树执行插入操作时，叶子节点的记录依然保持有序，我们需要同时考虑插入到B+树的三种情况。

##### Leaf Page 未满 && Index Page 未满

直接将记录插入到叶子节点

在下面这棵二叉树中，要插入 23 这个元素，Leaf Page 和 Index Page 都未满。

![](/img/blog/2017-02-19-mysql2.png)

将元素 23 直接插入

![](/img/blog/2017-02-19-mysql3.png)


##### Leaf Page 满了 && Index Page 未满

- 拆分 Leaf Page
- 将中间的节点放入 Index Page 中
- 小于中间节点的记录放在左边
- 大于或等于中间节点的记录放在右边

![](/img/blog/2017-02-19-mysql4.png)

当前情况，Leaf Page 满了、Index Page 未满，我们要在B+树中插入一个元素 27 

首先先拆分 Leaf Page，将中间的节点放入 Index Page 中；将小于中间节点的元素放在原先的页中，保持不动，大于或等于中间节点的元素放到新的一个页中。

最后形成下面的B+树：


![](/img/blog/2017-02-19-mysql5.png)


##### Leaf Page 满了 && Index Page 满了

- 拆分 Leaf Page
- 小于中间节点的记录放在左边
- 大于或等于中间节点的记录放在右边
- 拆分 Index Page
- 小于中间节点的记录放在左边
- 大于中间节点的记录放在右边
- 中间节点放在上一层的 Index Page


![](/img/blog/2017-02-19-mysql5.png)

在上图的B+树中插入元素 45 ，这时候发现 Leaf Page 和 Index Page 都满了

首先我们要先拆分 Leaf Page，并且将小于中间节点的记录保留在原先的页中，大于或等于中间节点的记录放在新的页中，如下图：

![](/img/blog/2017-02-19-mysql6.png)

接着需要拆分 Index Page，小于中间节点的记录放在原先的 Index Page 中，大于或等于中间节点的记录放在新的 Index page 中，在新建一层 Index Page ，将中间节点放入。最后变成下图的B+树。

![](/img/blog/2017-02-19-mysql7.png)


###### 总结

不管如何插入，都要保证B+树是保持平衡的，但是为了保持平衡可能会出现需要做大量拆分页的情况。有一种情况是 Leaf Page 满了，但是它的左右兄弟 Leaf Page 没有满，那么为了减少页的拆分操作，会选择旋转操作来保证B+树的平衡。

假如出现如下图的情况：

我想在B+树中插入元素 28 

![](/img/blog/2017-02-19-mysql8.png)

会出现上面 Leaf Page 满了 && Index Page 未满 的情况，这时候的策略会对 Leaf Page 进行拆分。但是这种方式增加了磁盘读写的负担，可以采用旋转的方式，因为可以发现 Leaf Page 的 右兄弟 Leaf Page 还有空的位置。

进行旋转操作：


![](/img/blog/2017-02-19-mysql9.png)



# B+树删除操作

B+树的删除操作和插入操作一样，要保证B+树叶子节点的记录的有序，B+树使用填充因子来控制树的删除变化，填充因子的最小值为 50% ，删除操作会出现下面三种情况：

- 叶子节点小于填充因子，中间节点小于填充因子
	
	直接将记录从叶子节点中删除，如果该节点是 Index Page 的节点，那么将该节点的右节点作为 Index Page 的节点。
	
- 叶子节点大于或等于填充因子，中间节点小于填充因子

	合并叶子节点和它的兄弟节点，同时更新 Index Page 
	
- 叶子节点大于或等于填充因子，中间节点大于或等于填充因子

	1.合并叶子节点和它的兄弟节点
	
	2.更新 Index Page
	
	3.合并 Index Page 和它的兄弟节点





























