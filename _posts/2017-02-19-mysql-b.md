---
layout:     post
title:      "MySQL 索引的实现原理"
subtitle:   "学习 MySQL InnoDB 和 MyISAM 存储引擎索引的实现"
date:       2017-02-19
author:     "JianFeng"
header-img: ""
catalog: true
tags:
    - MySQL
---

> 学习 MySQL InnoDB 和 MyISAM 存储引擎索引的实现



# 索引

索引是我们在使用 MySQL 中经常遇到的，索引建立的好坏直接影响了我们的查询性能，建立索引是十分有讲究的。对于不同的 MySQL 存储引擎支持的索引类型也有所不同。



# InnoDB 下的索引

InnoDB 的索引实现主要有以下三种：

- B+树索引
- 全文索引
- 哈希索引


# 二分查找算法

学习B+树之前，我们先了解一下二分查找，有助于我们了解B+树的实现。

二分查找法也称为折半查找法，用来查找一组有序的记录数组中的某一个记录，其思想是将数据先进行有序处理，在查找过程中采用跳跃查找的方式，比如：1，2，3，4，5，6，7，8，9，10，需要找到8这个元素，数组初始下标为0，长度为10，折半查找，找到数组中间的元素 6 ，元素 6 左边的元素都小于 6 ，右边的元素都大于 6 。然后用 6 和 要查找的元素对比，发现 8 大于 6 ，说明我们要找的元素在 6 的右部分。在 7，8，9，10 这剩下几个元素中查找，折半后，中间的元素为 8 ，8 和 8 相等，找到该元素，使用传统方法顺序遍历，我们可能查找的复杂度为 O(n)，使用折半查找法时间复杂度为 O(logN)，是不是快了很多！

##### 二分查找法的实现

    public static void half(int[] arr,int target){
        int low = 0;
        int hight = arr.length-1;
        while(low<=hight){
            int mid = (low + hight) / 2;
            System.out.println(arr[mid]);
            if(arr[mid] == target){
                System.out.println(arr[mid]);
                return;
            }
            if(arr[mid] > target){
                hight = mid - 1;
            }else{
                low = mid + 1;
            }
        }
    }
    
    public static int[] arr = {1,2,3,4,5,6,7,8,9,10};
    
    public static void main(String[] args){
    	half(arr,8);
    }
    
运行程序将打印出 8 。




# B+树索引

B+树索引是从二叉树演化而来的，所以 B+树 的结构类似二叉树，二叉查找树是一个经典的数据结构，在二叉查找树中左子树的值都比根节点小，右子树都比根节点大。，比如在下面这课查找树中我们要找到元素8


![](/img/blog/2017-02-19-mysql.png)

根节点的值为5，元素 8 大于 5，说明 8 在该二叉查找树的右子树，在右子树进行查找，找到 7 ，发现 8 大于 7 ，然后查找 7 的右孩子，7 的右孩子为 8 ，找到了。二叉查找树平均查找速度要比顺序查找要快。但是，也会遇到一些极端的情况,看看下面这棵二叉查找树：

![](/img/blog/2017-02-19-mysql0.png)

当我要寻找元素 1 时，我们的查找顺序是这样的：6 -> 5 -> 4 -> 2 -> 1。加入使用顺序查找，查找次数为1，但是使用二叉查找树的次数为5。若想是二叉树的查找效率达到最大的话，那么我们需要保证这棵二叉树平衡的，平衡二叉树又称为AVL树。平衡二叉树必须满足以下条件：

- 符合二叉查找树定义
- 必须满足任何节点的两个子树的高度最大差为1。像刚刚的二叉树就不是平衡二叉树。




























