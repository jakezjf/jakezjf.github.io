
---
layout:     post
title:      "字符串比较 LD 算法"
subtitle:   "学习字符串比较 LD 算法"
date:       2016-10-08
author:     "JianFeng"
header-img: ""
catalog: true
tags:
    - 算法
---

> 学习字符串比较 LD 算法



# LD 算法
LD 算法是最常用的文本比较算法之一，LD 算法是 Levenshtein Distance 算法的简称(编辑距离算法)，该算法主要是比较一个字符串和另一个字符串之间的差异，比如字符串A要变成字符串B，需要进行插入、删除、替换等操作，我们需要知道最少的操作次数，使用 LD 算法可以帮我们计算最少操作次数。

比如：

string -> ktring

_tring 如果删除一个字符，那么 string 就是他们的公共子串，只需操作一个字符

abcd -> axbwcbd 

a_b_c_d -> 添加三个字符，最长公共子串为axbwcbd




# LD 算法的性质

- LD(A,A)=0

- LD(A,"")=Len(A)

- LD(A,B)=LD(B,A)

- 0≤LD(A,B)≤Max(Len(A),Len(B))

- LD(A,B)=LD(Rev(A),Rev(B))

- LD(A+C,B+C)=LD(A,B)

- LD(A+B,A+C)=LD(B,C)

- LD(A,B)≤LD(A,C)+LD(B,C) 

- LD(A+C,B)≤LD(A,B)+LD(B,C)


对于1≤i≤N，1≤j≤M，有公式一

若ai=bj，则LD(i,j)=LD(i-1,j-1)

若ai≠bj，则LD(i,j)=Min(LD(i-1,j-1),LD(i-1,j),LD(i,j-1))+1




# 举个栗子

GGATCGA

GAATTCAG

求两个字符串的最长公共子串

第一步将 G 换成 A

G**A**ATCGA

GAATTCAG

第二步在 T 前插入 T

GAA**T**TCGA

GAATTCAG

第三步将 G 替换为 A

GAATTC**A**A

GAATTCAG

第四步将 A 替换为1 G

GAATTCA**G**

GAATTCAG

创建两个数组，按照上面的公式

![](/img/blog/ld-0.jpg)

![](/img/blog/ld-1.jpg)

观察最右下角的结果为 4

LD(GGATCGA,GAATTCAG) = 4




# 代码实现

	    public static int ld(String str,String temp){
	        int[][] a = new int[str.length()][temp.length()];
	        for(int i = 0;i<str.length();i++){
	            for(int j = 0;j<temp.length();j++){
	//                System.out.println(str.charAt(i) + temp.charAt(j));
	                if(str.charAt(i) != temp.charAt(j)){
	                    if(i == 0 || j == 0){
	                        a[i][j] = 1;
	                    }else{
	                        int max = a[i-1][j];
	                        if(max<=a[i-1][j-1]){
	                            max = a[i-1][j-1];
	                        }
	                        if(max<=a[i][j-1]){
	                            max = a[i][j-1];
	                        }
	                        a[i][j] = max;
	//                        System.out.println(a[i][j]);
	                    }
	                }else{
	                    if(i == 0 || j == 0){
	                        a[i][j] = 1;
	                    }else{
	                        a[i][j] = a[i-1][j-1] + 1;
	                    }
	//                    System.out.println(a[i][j]);
	                }
	            }
	        }
	        for(int i = 0;i<str.length();i++){
	            for(int j = 0;j<temp.length();j++){
	                System.out.print(a[i][j] + "\t");
	            }
	            System.out.println();
	        }
	        return a[str.length()-1][temp.length()-1];
	    }


